# Copyright (c) 2025 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0 or MIT
#
#

import re
import json
import sys
import argparse

# Define the structure of the Rust struct
rust_struct_template ="""// Copyright (c) 2025 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0 or MIT
//
//

//
// This is autogenerated file - do not modify it
//

extern crate alloc;
use alloc::{{vec, vec::Vec}};

#[derive(Debug)]
pub struct CavsVector {{
{cavs_vector_field_code}
}}

pub fn get_cavs_vectors() -> Vec<CavsVector> {{
    let cavs_vectors = vec![
{cavs_vectors_code}
    ];
    return cavs_vectors;
}}
"""

# Function to parse hex string to Rust Vec<u8>
def parse_hex_string(hex_str):
    return f"vec![{', '.join(f'0x{hex_str[i:i+2]}' for i in range(0, len(hex_str), 2))}]"

# Function to parse integer string to Rust u32
def parse_int_string(int_str):
    return int(int_str.strip())

# Function to read and parse the CAVS input data
def read_cavs_input(filename, mapping, cavs_params_filter):
    cavs_params = {} # Keeps current value of CAVS vectors parameters
    cavs_vectors = [] # Keeps list of items added later to the output file
    current_cavs_vector = {} # Keeps elements for currently collected CAVS vector
    with open(filename, 'r') as file:
        for line in file:

            # Let's search for end of the CAVS group - it shall be marked by empty line
            if line == "\n" or line == "\r" or line == "\r\n":
                # Add the current line as comment anyway
                # cavs_vectors.append("        //" + line)

                if len(current_cavs_vector) > 0:
                    cavs_vectors.append("        CavsVector {\n" + ",\n".join(f"            {k}: {v}" for k, v in current_cavs_vector.items()) + "}")

                # Just clear current CAVS collection since starting collecting the new one
                current_cavs_vector = {}

                continue

            # Let's search for CAVS parameters - it shall be makred by "['Param' = 'Value']"
            re_res = re.search("^\[(.+)\s+=\s+(.+)\]$", line)
            if re_res:
                cavs_params.update({re_res.group(1) : parse_int_string(re_res.group(2))})

                # Add the current line as comment
                # cavs_vectors.append("        //" + line)

                # Clear collecting CAVS parameters so just for sure clear current CAVS collection
                current_cavs_vector = {}

                continue

            # Check if current CAVS parametes matches the one from user CAVS parameters filter file
            filter_matched = True
            for cavs_param_name,cavs_param_value in cavs_params_filter.items():
                if cavs_param_value != "any":
                    if not cavs_param_name in cavs_params:
                        # If parameter exists in the filter file and is different than 'any' but
                        # is not available in the current params just drop current line
                        filter_matched = False
                        break
                    elif cavs_params[cavs_param_name] != cavs_param_value:
                        # If parameter exists in the filter file and is different than 'any' and
                        # is available in the current params but value is diffent just drop current line
                        filter_matched = False
                        break

            if not filter_matched:
                # Add the current line as comment
                # cavs_vectors.append("        //" + line)

                # Clear collecting CAVS parameters so just for sure clear current CAVS collection
                current_cavs_vector = {}

                continue

            entry_matched = False
            for cavs_field, struct_info in mapping.items():
                struct_field = struct_info['name']
                struct_type = struct_info['type']
                re_res = re.search("^{0}\s+=\s+(.*)$".format(cavs_field), line)
                if re_res:
                    entry_matched = True
                    value = re_res.group(1)
                    if struct_type == "Vec<u8>":
                        current_cavs_vector[struct_field] = parse_hex_string(value)
                    elif struct_type == "u32":
                        current_cavs_vector[struct_field] = parse_int_string(value)
                    # Add more types if required

                    continue

            if not entry_matched:
                # Unreconized entry in the CAVS input cavs_vectors
                # Just put it as comment and start collecting CAVS input
                # vector data from scratch
                # cavs_vectors.append("        //" + line)
                current_cavs_vector = {}

    return cavs_vectors

# Function to generate Rust code
def generate_rust_code(cavs_vectors, mapping):
    # Generate the fields for the Rust struct
    cavs_vector_field_code = "    "
    cavs_vector_field_code += "\n    ".join([f"pub {info['name']}: {info['type']}," for info in mapping.values()])

    cavs_vectors_code = ""
    for cavs_vector in cavs_vectors:
        # Check if there is a comment
        if cavs_vector.startswith("        //"):
            cavs_vectors_code += cavs_vector

        # Otherwise having valid CAVS input data vector
        else:
            cavs_vectors_code += cavs_vector + ",\n"

    return rust_struct_template.format(cavs_vectors_code=cavs_vectors_code, cavs_vector_field_code=cavs_vector_field_code)

# Main function
def main():
    # Initialize parser
    parser = argparse.ArgumentParser()

    # Adding arguments
    # parser.add_argument("-h", "--help", help = "Help")
    parser.add_argument("-i", "--input", help = "CAVS input data vectors file")
    parser.add_argument("-m", "--mapping", help = "CAVS vectors file attributes to Rust structure field names mapping file")
    parser.add_argument("-f", "--filter", help = "CAVS vectors parameters filter file")
    parser.add_argument("-o", "--output", help = "Rust file with CAVS vectors")

    args = parser.parse_args()

    if args.input:
        input_filename = args.input

    if args.mapping:
        mapping_filename = args.mapping

    if args.filter:
        filter_filename = args.filter

    if args.output:
        output_filename = args.output

    if not args.input or not args.mapping or not args.output:
        print("Usage: python convert_cavs_to_rust.py -i <cavs_vectors.txt> -m <mapping.json> -f <filter.json> -o <output.rs>")
        sys.exit(1)

    # Read the mapping from a JSON file
    mapping = {}
    with open(mapping_filename, 'r') as file:
        mapping = json.load(file)

    # Read the CAVS vector parameters filter from a JSON file
    cavs_params_filter = {}
    if args.filter:
        with open(filter_filename, 'r') as file:
            cavs_params_filter = json.load(file)

    cavs_vectors = read_cavs_input(input_filename, mapping, cavs_params_filter)
    rust_code = generate_rust_code(cavs_vectors, mapping)

    with open(output_filename, 'w') as file:
        file.write(rust_code)

    print(f"Rust code has been written to {output_filename}")

if __name__ == "__main__":
    main()
