# Copyright (c) 2025 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0 or MIT
#
#

import re
import json
import sys
import argparse

# Define the structure of the Rust struct
rust_struct_template ="""// Copyright (c) 2025 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0 or MIT
//
//

//
// This is autogenerated file - do not modify it
//

pub struct CavsVector<'a> {{
{cavs_vector_field_code}
}}

pub fn get_cavs_vectors() -> [CavsVector<'static>; {cavs_vectors_count}] {{
    [
{cavs_vectors_code}
    ]
}}
"""

# Function to parse hex string to Rust Vec<u8>
def parse_hex_string(hex_str):
    return f"&[{', '.join(f'0x{hex_str[i:i+2]}' for i in range(0, len(hex_str), 2))}]"

# Function to parse integer string to Rust u32
def parse_int_string(int_str):
    return int(int_str.strip())

def parse_string_string(str_str):
    return f"\"{str_str}\""

# Function to read and parse the CAVS input data
def read_cavs_input(filename, mapping, cavs_params_filter):
    cavs_params_global = {} # Keeps global CAVS vectors parameters
    cavs_params = {} # Keeps current value of CAVS vectors parameters
    cavs_vectors = [] # Keeps list of items added later to the output file
    current_cavs_vector = {} # Keeps elements for currently collected CAVS vector
    with open(filename, 'r') as file:
        stop_collecting_current_vector = False
        for line in file:

            # Let's search for end of the CAVS group - it shall be marked by empty line
            if line == "\n" or line == "\r" or line == "\r\n":
                # Add the current line as comment anyway
                # cavs_vectors.append("        //" + line)

                if len(current_cavs_vector) > 0:
                    # Handle all the parameters (struct fields) with attribute "global"
                    # Just add them blindly to the final CAVS vector
                    for struct_field, value in cavs_params_global.items():
                        current_cavs_vector[struct_field] = value

                    cavs_vectors.append("        CavsVector {\n" + ",\n".join(f"            {k}: {v}" for k, v in current_cavs_vector.items()) + "}")

                # Just clear current CAVS collection since starting collecting the new one
                current_cavs_vector = {}

                stop_collecting_current_vector = False

                continue

            if stop_collecting_current_vector:
                continue

            # Let's search for CAVS parameters - it shall be marked by "['Param' = 'Value']"
            re_res = re.search("^\[(.+)\s+=\s+(.+)\]$", line)
            if re_res:
                cavs_params.update({re_res.group(1) : parse_int_string(re_res.group(2))})

                # Add the current line as comment
                # cavs_vectors.append("        //" + line)

                # Clear collecting CAVS parameters so just for sure clear current CAVS collection
                current_cavs_vector = {}

                continue
            else:
                # Let's search for CAVS configuration - it could be marked by "['configuration']"
                re_res = re.search("^\[(.+)\]$", line)
                if re_res:
                    cavs_params.update({"configuration" : re_res.group(1)})

                    # Add the current line as comment
                    # cavs_vectors.append("        //" + line)

                    # Clear collecting CAVS parameters so just for sure clear current CAVS collection
                    current_cavs_vector = {}

                    continue


            # Check if current CAVS parametes matches the one from user CAVS parameters filter file
            filter_matched = True
            for cavs_param_name,cavs_param_value in cavs_params_filter.items():
                if cavs_param_value != "any":
                    if not cavs_param_name in cavs_params:
                        # If parameter exists in the filter file and is different than 'any' but
                        # is not available in the current params just drop current line
                        filter_matched = False
                        break
                    elif cavs_params[cavs_param_name] != cavs_param_value:
                        # If parameter exists in the filter file and is different than 'any' and
                        # is available in the current params but value is diffent just drop current line
                        filter_matched = False
                        break

            if not filter_matched:
                # Add the current line as comment
                # cavs_vectors.append("        //" + line)

                # Clear collecting CAVS parameters so just for sure clear current CAVS collection
                current_cavs_vector = {}

                continue

            entry_matched = False
            for cavs_field, struct_info in mapping.items():
                struct_field = struct_info['name']
                struct_type = struct_info['type']
                try:
                    attr = struct_info['attr']
                except:
                    attr = ""
                try:
                    match = struct_info['match']
                except:
                    match = ""

                re_res = re.search("^{0}\s+=\s+(.*)$".format(cavs_field), line)
                if re_res:
                    entry_matched = True
                    value = re_res.group(1)
                    if struct_type == "&'a [u8]":
                        value_conv = parse_hex_string(value)
                    elif struct_type == "u32":
                        value_conv = parse_int_string(value)
                    elif struct_type == "&'a str":
                        value_conv = parse_string_string(value)
                    # Add more types if required

                    # Check if CAVS field shall be matched with the pattern
                    matching = "NA"
                    if match != "":
                        re_res = re.search("^(.*):(.*)$", match)
                        if re_res:
                            if re_res.group(1) == "equal":
                                if value.strip() == re_res.group(2):
                                    matching = "YES"
                                else:
                                    matching = "NO"
                            elif re_res.group(1) == "any":
                                for value_in_match in re_res.group(2).split(";"):
                                    value_str = value.strip().strip("\"")
                                    if value_str in value_in_match:
                                        matching = "YES"
                                        break
                                    else:
                                        matching = "NO"

                    # In case parameter with attribute "global" just put it into extra dictionary and use later
                    if attr == "global":
                        # Do not use this entry
                        cavs_params_global.update({struct_field : value_conv})
                    else:
                        if matching == "NA":
                            # There was no matching so adding the value
                            current_cavs_vector[struct_field] = value_conv
                        elif matching == "NO":
                            # There was matching but failed so stop collecting current vector
                            stop_collecting_current_vector = True
                            current_cavs_vector = {}
                        elif matching == "YES":
                            # Just in case 'matching' was previously set to True
                            stop_collecting_current_vector = False
                            # There was matching and it succeeded so continue collecting current
                            # vector but do not add this field

                    continue

                if stop_collecting_current_vector:
                    break

            if stop_collecting_current_vector:
                continue

            if not entry_matched:
                # Unreconized entry in the CAVS input cavs_vectors
                # Check if CAVS input data matches the pattern 'Param = value'
                re_res = re.search("^.+\s+=\s+.*$", line)
                if not re_res:
                    # Entry does not follow the required pattern. Stop collecting CAVS
                    # params
                    current_cavs_vector = {}
                # else:
                    # Found 'Param' which is not required so just continue collecting
                    # CAVS params and put the line as comment
                    # cavs_vectors.append("        //" + line)

    return cavs_vectors

# Function to generate Rust code
def generate_rust_code(cavs_vectors, mapping):
    # Generate the fields for the Rust struct
    cavs_vector_field_code = "    "
    filtered_mapping = {k: v for k, v in mapping.items() if "match" not in v}
    cavs_vector_field_code += "\n    ".join([f"pub {info['name']}: {info['type']}," for info in filtered_mapping.values()])

    cavs_vectors_code = ""
    cavs_vectors_count = 0
    for cavs_vector in cavs_vectors:
        # Check if there is a comment
        if cavs_vector.startswith("        //"):
            cavs_vectors_code += cavs_vector

        # Otherwise having valid CAVS input data vector
        else:
            cavs_vectors_code += cavs_vector + ",\n"
            cavs_vectors_count += 1

    return rust_struct_template.format(cavs_vectors_code=cavs_vectors_code, cavs_vector_field_code=cavs_vector_field_code, cavs_vectors_count=cavs_vectors_count)

# Main function
def main():
    # Initialize parser
    parser = argparse.ArgumentParser()

    # Adding arguments
    # parser.add_argument("-h", "--help", help = "Help")
    parser.add_argument("-i", "--input", help = "CAVS input data vectors file")
    parser.add_argument("-m", "--mapping", help = "CAVS vectors file attributes to Rust structure field names mapping file")
    parser.add_argument("-f", "--filter", help = "CAVS vectors parameters filter file")
    parser.add_argument("-o", "--output", help = "Rust file with CAVS vectors")

    args = parser.parse_args()

    if args.input:
        input_filename = args.input

    if args.mapping:
        mapping_filename = args.mapping

    if args.filter:
        filter_filename = args.filter

    if args.output:
        output_filename = args.output

    if not args.input or not args.mapping or not args.output:
        print("Usage: python convert_cavs_to_rust.py -i <cavs_vectors.txt> -m <mapping.json> -f <filter.json> -o <output.rs>")
        sys.exit(1)

    # Read the mapping from a JSON file
    mapping = {}
    with open(mapping_filename, 'r') as file:
        mapping = json.load(file)

    # Read the CAVS vector parameters filter from a JSON file
    cavs_params_filter = {}
    if args.filter:
        with open(filter_filename, 'r') as file:
            cavs_params_filter = json.load(file)

    cavs_vectors = read_cavs_input(input_filename, mapping, cavs_params_filter)
    rust_code = generate_rust_code(cavs_vectors, mapping)

    with open(output_filename, 'w') as file:
        file.write(rust_code)

    print(f"Rust code has been written to {output_filename}")

if __name__ == "__main__":
    main()
